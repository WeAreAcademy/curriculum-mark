# Philosophy
## Our context
As detailed in our [goals](GOALS.md), we are aiming prepare people for roles as associate/junior software engineers.

In the particular [Academy](https://www.notion.so/Academy-92e6a8b244894a4d9b7d0b785c3d4bd2) context, we are doing this over:
- 16 weeks of pre-employment training;
- with [competitively selected graduates](https://www.notion.so/Scholars-Identifying-and-diverting-future-leaders-into-tech-8fa991cdab284add9926bb690667f6e3);
- at no cost to our Scholars; and
- with a follow-on 21 month placement and programme.

[Read more about Academy's Graduate Programme here.](https://www.notion.so/Graduate-Programme-Building-early-career-tech-leaders-fd95d2f498814a50af004ce7279f63c7)

## Our approach
We have a few principles. Sometimes, they may conflict, but we take them as guiding thoughts and try to deal sensibly with conflcits where they arise.

| Principle name | Prioritise... | ... over ... |
| --- | --- | --- |
| Independence | Instructor-light learning | Instructor-heavy learning |
| Adaptability | Ideas | Syntax |

### Independence
Working as a software engineer means working in a team (you're not an isolated silo) but it _also_ means being able to try figuring things out by yourself.

Our goal is to prepare Scholars to have that independence.

As such, we *prioritise instructor-light learning over instructor-heavy learning*.

To us, this means things like:
- We prefer to build activities ('try this exercise on inheritance') over lesson scripts ('listen to us talking about inheritance')
- We design activities to be supplemented by Google instead of being entirely standalone

But it _doesn't_ mean that:
- We provide no explanations - instead, we're careful that these don't replace activities
- We provide no materials - instead, we're careful that we also build the muscle of 'finding and parsing information'

### Adaptability
Working as a software engineer means learning new languages, libraries and frameworks, and transfering the concepts between them.

Our goal is to prepare Scholars to have that adaptability.

As such, we *prioritise ideas over syntax*.

To us, this means things like:
- We pick a curriculum language for the sake of a common vocabulary, rather than for the sake of "we are learning JavaScript"

But it _doesn't_ mean that:
- We entirely ignore syntax - instead, we're trying to cultivate "we're covering higher-order functions, and we _happen_ to be using JavaScript, but _the idea is transferable_"

### Cover fundamentals


In our context, we have 16 weeks with Scholars before they start employment - and, when they start work, we want them to have covered the fundamentals. We will have failed them if they have never used a version control system.

As such, we *prioritise explicit sequencing over discovery learning*.

To us, this means things like:
- Identify important foundational skills (e.g. 'naming variables well') and target them instead of relying on learners picking them up by osmosis
