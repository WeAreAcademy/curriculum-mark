# Philosophy
## Our context
As detailed in our [goals](GOALS.md), we are aiming prepare people for roles as associate/junior software engineers.

In the particular [Academy](https://www.notion.so/Academy-92e6a8b244894a4d9b7d0b785c3d4bd2) context, we are doing this over:
- 16 weeks of pre-employment training;
- with [competitively selected graduates](https://www.notion.so/Scholars-Identifying-and-diverting-future-leaders-into-tech-8fa991cdab284add9926bb690667f6e3);
- at no cost to our Scholars; and
- with a follow-on 21 month placement and programme.

[Read more about Academy's Graduate Programme here.](https://www.notion.so/Graduate-Programme-Building-early-career-tech-leaders-fd95d2f498814a50af004ce7279f63c7)

## Our approach
We have a few principles that we try to adhere to. There can be a tension between some of these, but we take them as guiding thoughts and try to deal sensibly with conflicts where they arise.

| Principle name | Prioritise... | ... over ... |
| --- | --- | --- |
| Independence | Instructor-light learning | Instructor-heavy learning |
| Adaptability | Ideas | Syntax |
| Toolkitting | Explicit exposure | Implicit osmosis |

### Independence
Working as a software engineer means working in a team (you're not an isolated silo) but it _also_ means being teaching yourself new things.

Our goal is to prepare Scholars to have that independence.

As such, we *prioritise instructor-light learning over instructor-heavy learning*.

To us, this means things like:
- We prefer to build activities ('try this exercise on inheritance') over lesson scripts ('listen to us talking about inheritance')
- We design activities to be supplemented by Google instead of being entirely standalone

But it _doesn't_ mean that:
- We provide no explanations - instead, we're careful that these don't replace activities
- We provide no materials - instead, we're careful that we also build the muscle of 'finding and parsing information'

### Adaptability
Working as a software engineer means learning new languages, libraries and frameworks, and transfering the concepts between them.

Our goal is to prepare Scholars to have that adaptability.

As such, we *prioritise ideas over syntax*.

To us, this means things like:
- We pick a curriculum language for the sake of a common vocabulary, rather than for the sake of "we are learning JavaScript"

But it _doesn't_ mean that:
- We entirely ignore syntax - instead, we're trying to cultivate "we're covering higher-order functions, and we _happen_ to be using JavaScript, but _the idea is transferable_"

### Toolkitting
Working as a software engineer means building on prior art using a toolkit of patterns, rather than perpetually inventing, creating or discovering things yourself.

Our goal is to prepare Scholars to have that toolkit to build on prior art.

As such, we *prioritise explicit exposure over implicit osmosis*.

To us, this means things like:
- We prefer to explicitly introduce mental models (e.g. 'thinking about value equality vs reference equality') where we think they are complex to develop
- We prefer to explicitly introduce useful skills and standards (e.g. 'how to write a good git commit message') over assuming that they will develop organically

But it _doesn't_ mean that:
- We provide explicit mental models for _everything_ - instead, we're trying to identify 'high-leverage tools that are commonly hard for a novice to organically discover'
